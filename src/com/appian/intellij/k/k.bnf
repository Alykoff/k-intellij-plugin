{
  parserClass="com.appian.intellij.k.parser.KParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="K"
  psiImplClassSuffix="Impl"
  psiPackage="com.appian.intellij.k.psi"
  psiImplPackage="com.appian.intellij.k.psi.impl"

  elementTypeHolderClass="com.appian.intellij.k.psi.KTypes"
  elementTypeClass="com.appian.intellij.k.psi.KElementType"
  tokenTypeClass="com.appian.intellij.k.psi.KTokenType"

  /*  http://kparc.com/parse.txt

.a.c[x]

%(a - b)
(x + 5; x: 20; x - 5)

(-;3)
(3 +) 4
(-:)3
(%-)[a;b]

d[%-;23;-:]

-3 --4

-3 (--:) 4 / valid
/-3 --: 4 /invalid


1 /: 2

/ comment

  1 2 2.4 (3) 0N 3 43 0i / numbers

  19

  1 +/:\: 44 / asdfadsf

  3 (2 4;)

  (1; 3
  5 (;);;; 3)

  :r

  d[.]

  a _bin b

  _bin[a;b]

  ifd [1;3;4]

  {[x;(y);z]
    1
    2
    (1 2
      3 4)
  }

  (1;2) 3

{}3

if[1;3;4]

  :x:::[1;2;3] / something

  (;)

  if[1;3;(3);3]

  sdfdf[1;(1;3;(3
  );{});3]

  a[;;
  3;a;(4
  4)]

  x:[1;4]

  x[i]:y

  10 +\:/:? 12 / something here

  12.5 + -*33 + --+----41

  f:{a : 10; : x + a; a : 20}
  f[5] 15

   1 33

  "string"

  (1 2 3 4)


x: 10

   25 20 5

  (1;2;3;4)

  `"asdfadsf"

  {`"symbol"}

  {x - 2} 5

  (1; "a"; 3.5; `xyz) 2

  _bin[a;b] / todo: invocation

  {x - 2} 5 6

a + b

  `a `b

  `b`s`d

  (identifier)

  1 +/10 3 4 5


  TOKEN ;a0`"+

  a:[a-zA-Z]                         / alpha
  d:[0-9]                            / digit
  p:[;()[]{}]                        / punctuation
  o:[:+-*%!&|<>=~,^#_$?@.'/\]        / operator

  n:(![]})ad]-)?(d*.)?d+(e-?d+)?        / number, e.g. -2
  i:a[ad]*                              / identifier
  s:`[ad]*                              / symbol
  t:p|i(.i)*|n( n)*|s+|"_*"|o:?| (/_*)? / token

  (+:;a.b;2 -.3;`a`bc) / nine tokens and comment

  lexical analysis is fairly simple. punctuation is normal. operators have optional':'.
  characters("ab"), numbers(2 -3) and symbols(`a`bc) are atom or vector(more than one).
  "2-3" is three tokens and "2 -3" is one token. end-of-line comment with [space]/ .

  PARSE Noun(x) Verb(+) Adverb(/)

  e:nve|te| t:n|v v:tA|V n:t[E]|(E)|[E]|{E}|N E:;e

  (+/x)%#x  is  (%;((/;+);x);(#:;x))

  SCRIPTS have nested multi-line comments with / and \ .
  multi-line functions(and data) with indentation. newlines are treated like ;'s .  */

  tokens=[

    // ascii chars
    bang='!'
    quote='"'
    hash='#'
    dollar='$'
    percent='%'
    ampersand='&'
    open_paren='('
    close_paren=')'
    asterisk='*'
    plus='+'
    comma=','
    dash='-'
    period='.'
    colon=':'
    semicolon=';'
    less_than='<'
    equals='='
    greater_than='>'
    question_mark='?'
    at='@'
    open_bracket='['
    close_bracket=']'
    caret='^'
    underscore='_'
    back_tick='`'
    open_brace='{'
    pipe='|'
    close_brace='}'
    tilde='~'

    // adverbs
    slash='/'
    slash_colon='/:'
    back_slash='\'
    back_slash_colon='\:'
    tick="'"
    tick_colon="':"

    // names
    identifier='regexp:[a-zA-Z][._a-zA-Z0-9]*'
    identifier_sys='regexp:_[._a-zA-Z0-9]*'

    // nouns
    nil='_n'
    number='regexp:((0|[1-9]\d*)(\.\d+)?([eE][+-]?\d*)?|0[iInN])'
    char='regexp:"(\\"|[^"])"'
    string='regexp:"(\\"|[^"])*"'

    // system verbs and nouns

    // i/o, dynamic load and client/server
    zeroColon='0:'
    oneColon='1:'
    twoColon='2:'
    threeColon='3:'
    fourColon='4:'
    fiveColon='5:'
    sixColon='6:'

    // assign, define, control and debug
    if="if"
    do="do"
    while="while"

    // punctuation
    newline='regexp:\r|\n|\r\n'
  ]
}

root ::= E0+ <<eof>>
private E0 ::= directory
             | E1
private E1 ::= separator
             | E4
private E2 ::= separator
             | E3
private E3 ::= E4
             | verb
             | composed_verb
             | composed_monad
private E4 ::= control
             | comment
             | E5
private E5 ::= assignment
//             | conditional
             | result
//             | indexing
             | value
//             | group

private separator ::= semicolon | newline

group ::= open_paren E3 close_paren

private id ::= identifier | identifier_sys

private value ::= dyad | monad_value
dyad ::= noun infix value
private monad_value ::= monad | noun
monad ::= op monad_value | projection

noun ::= noun_only | noun_and_op
private noun_only ::= vector | atom | conditional | indexing | group
private noun_and_op ::= id | lambda | group | list | nil

private vector ::= symbol_vector | number_vector | string
list ::= open_paren ([E3] separator [E3])* close_paren

private atom ::= symbol | number | char
lambda ::= open_brace [index] E1* close_brace

indexing ::= (id | group | lambda) index
private index ::= open_bracket E2* close_bracket
control ::= (if | do | while) index

infix ::= verb | identifier_sys | derived_verb

projection ::= noun infix !noun

private op ::= verb | composed_verb | derived_verb | noun_and_op

assignment ::= id [index] [verb] colon E5
             | id colon colon E5

conditional ::= colon index

result ::= colon E5
